package main

import (
	"bytes"
	"fmt"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"strings"

	"github.com/y0za/interfake/model"
)

type Generator struct {
	buf *bytes.Buffer
	pt  model.PackageTable
}

func NewGenerator() *Generator {
	return &Generator{
		buf: bytes.NewBufferString(""),
	}
}

func (g *Generator) p(format string, args ...interface{}) {
	fmt.Fprintf(g.buf, format+"\n", args...)
}

func (g *Generator) Generate(intf *model.Interface, pkgName string, outputPackagePath string) error {
	g.p("// This code is generated by github.com/y0za/interfake. DO NOT EDIT.")
	g.p("package %v", pkgName)

	pps := intf.PackagePaths()
	g.pt = model.PackageTable{}
	for path, _ := range pps {
		split := strings.Split(path, "/")
		name := split[len(split)-1]
		g.pt[path] = name
	}

	g.p("")
	g.p("import (")
	for path, _ := range pps {
		if path == outputPackagePath {
			continue
		}
		g.p(`"%s"`, path)
	}
	g.p(")")

	return g.generateFakeImpl(intf, outputPackagePath)
}

func (g *Generator) generateFakeImpl(intf *model.Interface, outputPackagePath string) error {
	g.p("")
	g.p("type Fake%s struct {", intf.Name)

	for _, m := range intf.Methods {
		f := model.FuncType{m.Args, m.Results}
		g.p("Fake%s %s", m.Name, f.String(g.pt))
	}

	g.p("}")

	for _, m := range intf.Methods {
		fa := formalArgsString(m.Args, g.pt)
		aa := actualArgsString(m.Args)
		r := resultsString(m.Results, g.pt)

		g.p("")
		g.p("func (f *Fake%s) %s(%s)%s {", intf.Name, m.Name, fa, r)
		if len(m.Results) == 0 {
			g.p("f.Fake%s(%s)", m.Name, aa)
		} else {
			g.p("return f.Fake%s(%s)", m.Name, aa)
		}
		g.p("}")
	}

	return nil
}

func (g *Generator) Format() error {
	formatted := &bytes.Buffer{}
	fs := token.NewFileSet()

	node, err := parser.ParseFile(fs, "", g.buf, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("failed parsing generated code: %v", err)
	}

	err = format.Node(formatted, fs, node)
	if err != nil {
		return fmt.Errorf("failed formatting generated code: %v", err)
	}

	g.buf = formatted
	return nil
}

func (g *Generator) WriteTo(w io.Writer) (int64, error) {
	return g.buf.WriteTo(w)
}

func formalArgsString(params []*model.Parameter, pt model.PackageTable) string {
	args := make([]string, len(params))
	for i, p := range params {
		name := p.Name
		if name == "" {
			name = fmt.Sprintf("a%d", i)
		}
		args[i] = fmt.Sprintf("%s %s", name, p.Type.String(pt))
	}
	return strings.Join(args, ", ")
}

func actualArgsString(params []*model.Parameter) string {
	args := make([]string, len(params))
	for i, p := range params {
		name := p.Name
		if name == "" {
			name = fmt.Sprintf("a%d", i)
		}
		args[i] = name
	}
	return strings.Join(args, ", ")
}

func resultsString(params []*model.Parameter, pt model.PackageTable) string {
	results := make([]string, len(params))
	for i, p := range params {
		results[i] = p.Type.String(pt)
	}
	resultsStr := strings.Join(results, ", ")
	if rc := len(params); rc == 1 {
		resultsStr = " " + resultsStr
	} else if rc > 1 {
		resultsStr = " (" + resultsStr + ")"
	}
	return resultsStr
}
